<p><span style="color: #000000;"><strong><span style="font-size: 24pt; font-family: verdana, geneva, sans-serif;">What
                is XHR (XMLHttp Request) ?</span></strong></span><br /><span style="font-size: 14pt;">We can made ajax
        request with plain js using XHR object.Ajax is a simple XMLHttpRequest in javascript. </span></p>
<p><span style="font-size: 14pt;">Use <span style="color: #ff0000;"><strong>XMLHttpRequest</strong> </span>(XHR) objects
        to interact with servers. You can retrieve data from a URL<strong><span style="color: #ff0000;"> without having
                to do a full page refresh</span></strong>. This enables a Web page to update just part of a page without
        disrupting what the user is doing. XMLHttpRequest is used heavily in AJAX programming.</span></p>
<p><span style="font-size: 14pt;">Library that can performs ajax calls or HTTP request are : <span
            style="color: #000000;"><strong>jQuery, Axios, FetchApi, Superagent, Prototype,
                NodeHttp</strong></span></span></p>
<h2><strong><span style="color: #ff0000;">Microservice Security ?</span></strong></h2>
<h4 style="text-align: justify;"><span style="font-family: verdana, geneva, sans-serif;">Modern applications are
        designed and deployed as a collection of <span style="color: #ff0000;">loosely coupled domain/business driven
            services</span> based on microservices architecture. These services and web applications should be <span
            style="color: #ff0000;">stateless</span> and <span style="color: #ff0000;">decouple </span>so that can be
        deployed, scaled in the cloud easily. <span style="color: #ff0000;">Token based security</span> is heart of
        microservices Security and it used to secure microservices services instead of traditional cookie (form) based
        security.</span></h4>
<h4><span style="font-size: 24pt;"><strong>What is Cookie based security?&nbsp;</strong></span></h4>
<p style="text-align: justify;"><span style="font-family: verdana, geneva, sans-serif; font-size: 14pt;">It is <span
            style="color: #ff00ff;"><strong>stateful</strong></span>, server keep track of sessions and client (browser)
        holds session identifier in the cookie. Server verifies the credentials and creates a session on the server and
        then set a cookie with the session identifier in the browser. It is <span
            style="color: #ff0000;">implicit</span> ie. browser&nbsp; automatically adds headers (ie. SessionId with in
        a cookie) and then&nbsp; send to server to make session authenticate with <span
            style="color: #ff0000;"><strong>every request</strong></span> to the domain (and due to this <strong><span
                style="color: #ff0000;">CSRF attack is possible</span></strong>). There is a major problem with Cookies,
        they doesn&rsquo;t work from domains they&rsquo;re not valid for so client system can&rsquo;t access cross
        domain resources/APIs.</span></p>
<p style="text-align: justify;"><span style="font-family: verdana, geneva, sans-serif; font-size: 14pt;">As Session ID
        is send on each request to validate the user so, that CSRF attack is possible .</span></p>
<p style="text-align: justify;"><span style="font-family: verdana, geneva, sans-serif; font-size: 14pt;">Donot work on
        cross domain.</span></p>
<p><img class="img-responsive" style="display: block; margin-left: auto; margin-right: auto;"
        src="http://proficientblog.com/wp-content/uploads/2017/12/CookieBasedvsdx.jpg" alt="" /></p>
<p>&nbsp;</p>
<p id="ca1b" class="graf graf--p graf-after--p"><span
        style="font-size: 14pt; font-family: verdana, geneva, sans-serif;"><strong
            class="markup--strong markup--p-strong">Basic flow of session based authentication:</strong></span></p>
<ol class="postList">
    <li id="14a2" class="graf graf--li graf-after--p"><span
            style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">In the browser User enters his username
            and password and the request goes from the client application to the server.</span></li>
    <li id="8b70" class="graf graf--li graf-after--li"><span
            style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">Server checks for the user name and
            password and if correct then authenticates it and sends a unique token to the user&rsquo;s client
            application. (also saves this unique token in memory or database)</span></li>
    <li id="f017" class="graf graf--li graf-after--li"><span
            style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">The client application stores the token
            in cookies, and sends it back with each subsequent request.</span></li>
    <li id="67f3" class="graf graf--li graf-after--li"><span
            style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">The server receives every request that
            requires authentication and uses the token to authenticate the user and return the requested data back to
            the client application.</span></li>
    <li id="603e" class="graf graf--li graf-after--li"><span
            style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">When someone logs out, the client
            application removes that token, and so that subsequent request to rails from the client becomes
            unauthorized.</span></li>
</ol>
<p>&nbsp;</p>

<p id="f197" class="graf graf--p graf-after--figure"><span
        style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">A few major problems arose with this method
        of authentication.</span></p>
<ul class="postList">
    <li id="2c97" class="graf graf--li graf-after--p"><span
            style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">Every time a user is authenticated, the
            server will need to create a record somewhere on the server. This is usually done in memory and when there
            are many users authenticating, the overhead on the server increases.</span></li>
    <li id="5be5" class="graf graf--li graf-after--li"><span
            style="font-size: 14pt; font-family: verdana, geneva, sans-serif;">Since sessions are stored in memory, this
            provides problems with scalability. If you replicate your server to multiple instances then you have to
            replicate all of the user sessions to all your servers., which complicates the scalability process. (Though
            it can be avoided by having a single dedicated server for session management but is not always feasible and
            easy to implement)</span></li>
</ul>
<br>
<h4><span style="font-size: 24pt; color: #000000;"><strong>What is Token based security (using JWT)?</strong></span>
</h4>
<p><span style="font-size: 14pt;">It is <span style="color: #ff00ff;">stateless</span>, server does not keep track of
        logged-in user&rsquo;s sessions. Authorization server (STS) issue a token to the client system and client send
        token in the request header <span style="color: #ff0000;">explicitly(Bearer tokens, or other HTTP header based
            tokens that need to be added manually)</span>, server uses it to verify the authenticity and access of the
        request (and due to this CSRF attack is not possible). Client system can send token to any domain to access the
        cross domain APIs (if CORS is enabled for the APIs).</span></p>
<p><span style="font-size: 14pt;"><img class="img-responsive"
            style="display: block; margin-left: auto; margin-right: auto;"
            src="http://proficientblog.com/wp-content/uploads/2017/12/TokenBasedvsdx.jpg" alt="" /></span></p>
<p><span style="font-size: 14pt;">Bearer tokens, or other HTTP header based tokens that need to be added manually, would
        prevent you from CSRF.</span></p>
<p><span style="font-size: 14pt;">&nbsp;If you use tokens that are stored in <span
            style="color: #ff0000;"><strong>session/local storage</strong></span> e.g., they are never automatically
        passed with the request. You probably use something like<span style="color: #ff0000;"><strong> angular
                interceptor</strong> </span>or similar technology to pass it along with every XHR request. This never
        happens automatically.</span></p>
<p><span style="font-size: 14pt;">Of course, but sort of off-topic, if you have a XSS vulnerability, an attacker could
        still access these tokens, but then it doesn't become a CSRF bug.</span></p>

<p id="428a" class="graf graf--p graf-after--p"><span style="font-size: 14pt; color: #ff0000;"><strong
            class="markup--strong markup--p-strong">Basic flow of token based authentication:</strong></span></p>
<ol class="postList">
    <li id="6c73" class="graf graf--li graf-after--p"><span style="font-size: 14pt;">User enters their login
            credentials</span></li>
    <li id="a248" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">Server verifies the credentials
            are correct and returns a signed token (the JWT) which can contain some additional information as a metadata
            like user_id, permissions etc.</span></li>
    <li id="7fb5" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">This token is stored client-side,
            most commonly in local storage &mdash; but can be stored in session storage or a cookie as well</span></li>
    <li id="31c3" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">Subsequent requests to the server
            include this token generally as an additional Authorization header in form of&nbsp;<em
                class="markup--em markup--li-em">Bearer {JWT}</em>, but can additionally be sent in the body of a POST
            request or even as a query parameter.</span></li>
    <li id="d555" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">The server decodes the JWT and if
            the token is valid, processes the request</span></li>
    <li id="726b" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">Once a user logs out, the token is
            destroyed client-side, no interaction with the server is necessary</span></li>
</ol>
<p id="1216" class="graf graf--p graf-after--p"><span style="font-size: 14pt; color: #ff0000;"><strong
            class="markup--strong markup--p-strong">There are several benefits of this method:</strong></span></p>
<ul class="postList">
    <li id="f908" class="graf graf--li graf-after--p"><span style="font-size: 14pt;">The biggest advantage of this
            method is that it is completely stateless as in the server doesn&rsquo;t need to store any record of the
            user tokens/sessions. Each token is self-contained, containing all the data required to check its validity
            as well as convey user information through claims. That&rsquo;s why it doesn&rsquo;t add any complexity in
            scalability.</span></li>
    <li id="2348" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">With a cookie based approach, you
            simply store the session id in a cookie. JWT&rsquo;s on the other hand allow you to store any type of
            metadata, as long as it&rsquo;s valid JSON.</span></li>
    <li id="b19a" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">When using the cookie based
            authentication, the back-end has to do a lookup, whether that be a traditional SQL database or a NoSQL
            alternative, and the roundtrip is likely to take longer compared to decoding a token. Additionally, since
            you can store additional data inside the JWT, such as the user&rsquo;s permission level, you can save
            yourself additional lookup calls to get and process the requested data.</span><br /><span
            style="font-size: 14pt;">For example, say you had an API resource /api/orders that retrieves the latest
            orders placed via your app, but only users with the role of admin have access to view this data. In a cookie
            based approach, once the request is made, you&rsquo;d have one call to the database to verify that the
            session is valid, another to get the user data and verify that the user has the role of admin, and finally a
            third call to get the data. On the other hand, with a JWT approach, you can store the user role in the JWT,
            so once the request is made and the JWT verified, you can make a single call to the database to retrieve the
            orders.</span></li>
    <li id="ae5f" class="graf graf--li graf-after--li"><span style="font-size: 14pt;">While possible, there are many
            limitations and considerations to using cookies with mobile platforms. Tokens on the other hand are much
            easier to implement on both iOS and Android. Tokens are also easier to implement for Internet of Things
            applications and services that do not have a concept of a cookie store.</span></li>
</ul>
<p id="f8cb" class="graf graf--p graf-after--li"><span style="font-size: 14pt;">Because of these benefits and simplified
        approach, Token based authentication is on the rise of popularity these days.</span></p>

<h2><strong><span style="color: #ff0000;">JSON WEB TOKEN BEST PRACTICES</span></strong></h2>
<p><span style="font-size: 12pt;">Before we actually get to implementing JWT, let&rsquo;s cover some best practices to
        ensure token based authentication is properly implemented in your application.</span></p>
<ul>
    <li><span style="font-size: 12pt;"><strong><span style="color: #ff0000;"><em>Keep it secret. Keep it
                        safe.</em></span>&nbsp;</strong>The signing key should be treated like any other credentials and
            revealed only to services that absolutely need it.</span></li>
    <li><span style="font-size: 12pt;"><span style="color: #ff0000;"><strong><em>Do not add sensitive data to the
                        payload.</em></strong></span>&nbsp;Tokens are signed to protect against manipulation and are
            easily decoded. Add the bare minimum number of claims to the payload for best performance and
            security.</span></li>
    <li><span style="font-size: 12pt;"><em><span style="color: #ff0000;"><strong>Give tokens an
                        expiration</strong></span>.</em>&nbsp;Technically, once a token is signed &ndash; it is valid
            forever &ndash; unless the signing key is changed or expiration explicitly set. This could pose potential
            issues so have a strategy for expiring and/or revoking tokens.</span></li>
    <li><span style="font-size: 12pt;"><em><span style="color: #ff0000;"><strong>Embrace
                        HTTPS</strong></span>.</em>&nbsp;Do not send tokens over non-HTTPS connections as those requests
            can be intercepted and tokens compromised.</span></li>
    <li><span style="font-size: 12pt;"><span style="color: #ff0000;"><strong><em>Consider all of your authorization use
                        cases.</em></strong></span>&nbsp;Adding a secondary token verification system that ensure tokens
            were generated from your server, for example, may not be common practice, but may be necessary to meet your
            requirements.</span></li>
</ul>

<h2>Refresh Token Vs Access Token</h2>
<img src="img/refresh token vs access token.png">
<br>
When user login then he will request to Auth Server then if successful , then Auth Server will generate both Access
Token and Refresh Token
and send back to client and using access token client can access the resource. As we know that token may have expired
time, and if token
expire then user used its stored refeash token to request Auth Server via login and Again Server will provide new Access
Token as well as Refresh Token.
=========================================================================================================
<h4><span style="color: #ff0000; font-size: 24pt;"><strong>Why token based security?</strong></span></h4>
<p style="text-align: justify;"><span style="font-size: 14pt;">It is stateless, scalable and decoupled, JWT token
        contains all the information to check its validity and user&rsquo;s identity and access details. Client system
        can access cross domain APIs using token, it is not possible with cookie without SSO. Cookie is not supported by
        every client system like native mobile apps but token based security can be easily implemented for Native mobile
        apps and Internet of Things.</span></p>
<h4><span style="font-size: 24pt; color: #ff0000;"><strong>What is JWT (JSON Web Tokens)?</strong></span></h4>
<p style="text-align: justify;"><span style="font-size: 14pt;">JWT tokens are JSON encoded data structures contains
        information about issuer, subject (claims), expiration time, access token, refresh token, id token etc. It is
        signed for tamper proof and authenticity and it can be encrypted to protect the token information using
        symmetric or asymmetric approach. JWT is simpler than SAML 1.1/2.0 and supported by all devices and it is more
        powerful than SWT(Simple Web Token).</span></p>

<br>
==================================================================================================================================================


<br>
<h4><span style="color: #ff0000;"><strong>What is OAuth2? (Passwordless authentication)&nbsp;</strong></span></h4>
<p><span style="font-size: 14pt;"><strong>Stands for <span style="color: #ff0000;">Open Standard for access
                Delegation.</span></strong></span></p>
<p><span style="font-size: 14pt;"><strong>While login with any site using google, facebook , gmail account we use
            OAuth.</strong></span></p>
<p><span style="font-size: 18pt;"><strong>How it work ?</strong></span></p>

<img src="Img/oauth 2.PNG">

<p style="text-align: justify;"><span style="font-size: 14pt;">Suppose you have client and server. Let say you login in
        Baniya Bank Account .For some reason your bank is asking you&nbsp; to authenticate your facebook account. So ,
        <strong><span style="color: #ff0000;">Baniya Bank</span></strong> acts as <strong><span
                style="color: #ff0000;">OAuth Client</span> </strong>and <strong><span
                style="color: #ff0000;">Facebook</span> <span style="color: #ff0000;">server</span></strong> as the
        <strong><span style="color: #ff0000;">OAuth Server</span></strong>. Suppose you have logged in Baniya Bank
        Account and from there it is asking you to connect to facebook account.So when you login to the facebook account
        ,then request goes from client(Bank) to Server (Facebook) saying can you plz authorize&nbsp; client with client
        Id (<strong><span style="color: #ff0000;"> bank client Id</span></strong>) is "..." ,(<span
            style="color: #ff0000;"><strong>Step 1</strong></span>) then when facebook get this message then facebook
        will popup saying </span><span style="font-size: 14pt;">"Do you want to Authorize the city bank to me? and&nbsp;
        it will show you your detial that you want to authorize and basically you can give your name, phone number and
        email etc. So we are giving these information to bank so here we are not giving username and password to baniya
        bank account so Just here facebook is delegating authorization to baniya bank via my authorization. Then after
        that will redirect to baniya bank website from facebook,(<strong><span style="color: #ff0000;">Step</span> <span
                style="color: #ff0000;">2</span></strong>) Here Baniya bank will recieve a token(authorization token)
        from facebook ie. Baniya bank now is </span><span style="font-size: 14pt;">getting privelage for making request
        to me</span></p>
<p style="text-align: justify;"><span style="font-size: 14pt;">Now for next request Baniya bank has to authenticate
        itself . so Baniya Bank send its own secret key and client Id ( these are bank key and bank Id), and token (my
        token) to facebook <strong><span style="color: #ff0000;">(Step 3)</span></strong> and as a result facebook will
        generate access token which is valid for that particular user for <strong><span style="color: #ff0000;">certain
                amount of time only</span></strong>.Now on each request baniya bank will send these generated token of
        mine for accessing facebook data.So, here we are getting account / infromation or say profile/ information of
        mine on facebook from facebook Resource Server.</span></p>
<p style="text-align: justify;"><br /><span style="font-size: 14pt;">So what happen here is we have authorization server
        as well as resource server . If we have just client and server architecture then you should not have to go&nbsp;
        with oauth2. OAuth2 is only used when lets say you have third party coming into a picture and you want to
        delegate authorization access from one place to another. Accessing my details is the main task here.</span></p>
<p style="text-align: justify;">&nbsp;</p>
<p style="text-align: justify;">&nbsp;</p>
<p style="text-align: justify;">&nbsp;</p>
<p style="text-align: justify;">&nbsp;</p>

<h2>Note: OAuth can use JWT token or other token</h2>


<h2>https://hackernoon.com/how-do-you-authenticate-mate-f2b70904cc3a</h2>


<!DOCTYPE html>
<html>

<head>
</head>

<body>
    <p>Tokens are special pieces of data that carry just <strong><span style="color: #169179;">enough
                information</span></strong> to <strong><span style="color: #169179;">either authorize the user to
                perform an actio</span></strong>n. It authorizes a user to access the resource.</p>
    <p>The user gets login /register then token gets generated then on each request this token is passed to access the
        resource.</p>
    <p>&nbsp;</p>
    <p>Actually token is generated using various ways like :</p>
    <ul style="list-style-type: disc;">
        <li>Symmetric JWT signatures</li>
        <li>Asymmetric JWT signatures</li>
        <li>JWT validation beyond signatures</li>
        <li>Cryptographic key management</li>
        <li>Using JWTs in practice</li>
    </ul>
    <p>&nbsp;</p>
    <p><span style="color: #169179;"><strong><span style="font-size: 18pt;">Symmetric JWT
                    signatures</span></strong></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">Decomposes JWT token in 3 components.</span></span>
    </p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">What happens is we store Secret Key in
                appsetting.json like this:</span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">"JwtSettings":&nbsp;<br />&nbsp; {<br />&nbsp;
                &nbsp; "Secret": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",<br />&nbsp; &nbsp; "TokenLifetime":
                "00:00:45"<br />&nbsp; },</span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">During Registration , user pass new email and
                password then his credential will get stored in database and then using&nbsp;</span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">this email and other information claim is created
                and this claim information is actually a payload.&nbsp;</span></span></p>
    <p>&nbsp;</p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">Using Secret Key +</span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Payload +
            </span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header
                information (contains signed information like using Jason Web Token
                {"alg":"HS256","typ":"JWT"})</span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= Signature is
                created (Authorization Server)</span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">This signature is passed after the login or
                registering process. This is a short live signature.</span></span></p>
    <p>&nbsp;</p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">Now to access actual resource , user will pass
                request url and access token , then what resource server will do is :</span></span></p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">look at the token extract header + payload&nbsp; ,
                then header + payload + Secret Key (from appsetting) combines and pass to hmac and generates signature.
            </span></span></p>
    <p>&nbsp;</p>
    <p><span style="color: #000000;"><span style="font-size: 18pt;">&nbsp;</span></span></p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
</body>

</html>